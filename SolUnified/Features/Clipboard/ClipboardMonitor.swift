//
//  ClipboardMonitor.swift
//  SolUnified
//
//  Monitor NSPasteboard for changes with source context capture
//

import Foundation
import AppKit

class ClipboardMonitor: ObservableObject {
    static let shared = ClipboardMonitor()
    
    private var timer: Timer?
    private var lastChangeCount: Int = 0
    private let pasteboard = NSPasteboard.general
    private let store = ClipboardStore.shared
    
    // MARK: - Privacy: Types to ignore (sensitive/transient content)
    private let ignoredTypes: [NSPasteboard.PasteboardType] = [
        NSPasteboard.PasteboardType("org.nspasteboard.TransientType"),
        NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType"),
        NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType"),
        NSPasteboard.PasteboardType("com.agilebits.onepassword"),
        NSPasteboard.PasteboardType("de.petermaurer.TransientPasteboardType"),
        NSPasteboard.PasteboardType("Pasteboard generator type"),
        NSPasteboard.PasteboardType("net.antelle.keeweb")
    ]
    
    // MARK: - Privacy: Apps to ignore (password managers, etc.)
    private let ignoredBundleIds: Set<String> = [
        "com.agilebits.onepassword7",
        "com.agilebits.onepassword8",
        "com.lastpass.LastPass",
        "com.bitwarden.desktop",
        "com.apple.keychainaccess"
    ]
    
    private init() {}
    
    func startMonitoring() {
        // Run on main thread to avoid threading issues
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            
            self.lastChangeCount = self.pasteboard.changeCount
            
            self.timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
                DispatchQueue.main.async {
                    self?.checkForChanges()
                }
            }
            
            print("ðŸ“‹ Clipboard monitoring started (with context capture)")
        }
    }
    
    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
        print("ðŸ“‹ Clipboard monitoring stopped")
    }
    
    private func checkForChanges() {
        let currentChangeCount = pasteboard.changeCount
        
        guard currentChangeCount != lastChangeCount else { return }
        
        lastChangeCount = currentChangeCount
        
        // 1. Privacy Check: Transient/Sensitive Types
        if let types = pasteboard.types {
            for ignored in ignoredTypes {
                if types.contains(ignored) {
                    print("ðŸš« Ignoring transient/sensitive clipboard content (type: \(ignored.rawValue))")
                    return
                }
            }
        }
        
        // 2. Capture Source Context (before processing)
        let currentApp = ActivityMonitor.shared.getCurrentApp()
        let sourceBundleId = currentApp?.bundleIdentifier
        let sourceAppName = currentApp?.localizedName
        let sourceWindowTitle = ActivityMonitor.shared.getActiveWindowTitle()
        
        // 3. Privacy Check: Ignored Apps
        if let bundleId = sourceBundleId, ignoredBundleIds.contains(bundleId) {
            print("ðŸš« Ignoring content from sensitive app: \(bundleId)")
            return
        }
        
        // 4. Process Content with context
        processClipboardContent(
            sourceBundleId: sourceBundleId,
            sourceAppName: sourceAppName,
            sourceWindowTitle: sourceWindowTitle
        )
    }
    
    private func processClipboardContent(sourceBundleId: String?, sourceAppName: String?, sourceWindowTitle: String?) {
        // Check for text
        if let text = pasteboard.string(forType: .string), !text.isEmpty {
            let hash = ClipboardStore.hashContent(text)
            let preview = text.prefix(100).description
            
            let item = ClipboardItem(
                contentType: .text,
                contentText: text,
                contentPreview: preview,
                contentHash: hash,
                createdAt: Date(),
                sourceAppBundleId: sourceBundleId,
                sourceAppName: sourceAppName,
                sourceWindowTitle: sourceWindowTitle
            )
            
            _ = store.saveItem(item)
            InternalAppTracker.shared.trackClipboardCopy(preview: preview)
            
            // Link to context graph
            ContextGraphManager.shared.linkClipboardItem(hash: hash)
            
            if let appName = sourceAppName {
                print("ðŸ“‹ Captured text from \(appName): \(preview.prefix(50))...")
            }
            return
        }
        
        // Check for image
        if let image = pasteboard.readObjects(forClasses: [NSImage.self])?.first as? NSImage {
            saveImage(image, sourceBundleId: sourceBundleId, sourceAppName: sourceAppName, sourceWindowTitle: sourceWindowTitle)
            return
        }
        
        // Check for file URL
        if let urls = pasteboard.readObjects(forClasses: [NSURL.self]) as? [URL], let url = urls.first {
            let hash = ClipboardStore.hashContent(url.path)
            let preview = url.lastPathComponent
            
            let item = ClipboardItem(
                contentType: .file,
                contentPreview: preview,
                filePath: url.path,
                contentHash: hash,
                createdAt: Date(),
                sourceAppBundleId: sourceBundleId,
                sourceAppName: sourceAppName,
                sourceWindowTitle: sourceWindowTitle
            )
            
            _ = store.saveItem(item)
            InternalAppTracker.shared.trackClipboardCopy(preview: preview)
            
            // Link to context graph
            ContextGraphManager.shared.linkClipboardItem(hash: hash)
            
            if let appName = sourceAppName {
                print("ðŸ“‹ Captured file from \(appName): \(preview)")
            }
            return
        }
    }
    
    private func saveImage(_ image: NSImage, sourceBundleId: String?, sourceAppName: String?, sourceWindowTitle: String?) {
        // Save image to temporary location
        guard let tiffData = image.tiffRepresentation,
              let bitmapImage = NSBitmapImageRep(data: tiffData),
              let pngData = bitmapImage.representation(using: .png, properties: [:]) else {
            return
        }
        
        let fileManager = FileManager.default
        let appSupport = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let clipboardDir = appSupport.appendingPathComponent("SolUnified/clipboard", isDirectory: true)
        
        try? fileManager.createDirectory(at: clipboardDir, withIntermediateDirectories: true)
        
        let filename = "clipboard_\(Int(Date().timeIntervalSince1970)).png"
        let fileURL = clipboardDir.appendingPathComponent(filename)
        
        do {
            try pngData.write(to: fileURL)
            
            let hash = ClipboardStore.hashContent(fileURL.path)
            
            // Build a more descriptive preview if we have context
            var preview = "Image"
            if let appName = sourceAppName {
                preview = "Image from \(appName)"
            }
            
            let item = ClipboardItem(
                contentType: .image,
                contentPreview: preview,
                filePath: fileURL.path,
                contentHash: hash,
                createdAt: Date(),
                sourceAppBundleId: sourceBundleId,
                sourceAppName: sourceAppName,
                sourceWindowTitle: sourceWindowTitle
            )
            
            _ = store.saveItem(item)
            InternalAppTracker.shared.trackClipboardCopy(preview: preview)
            
            // Link to context graph
            ContextGraphManager.shared.linkClipboardItem(hash: hash)
            
            print("ðŸ“‹ Captured image from \(sourceAppName ?? "unknown")")
        } catch {
            print("Failed to save clipboard image: \(error)")
        }
    }
}

